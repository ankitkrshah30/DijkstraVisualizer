// src/main/java/com/dmsproject/dijkstravisualizer/DijkstraController.java
package com.dmsproject.dijkstravisualizer;

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.*;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Pane;
import javafx.scene.text.Text;
import javafx.scene.paint.Color;
import javafx.util.Duration;
import org.jgrapht.Graph;
import org.jgrapht.Graphs;
import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.SimpleWeightedGraph;

import java.util.stream.Collectors;
import java.net.URL;
import java.util.*;

import static org.jgrapht.Graphs.addEdge;

// We will populate this controller in subsequent steps
public class DijkstraController implements Initializable {

    @FXML
    private BorderPane mainBorderPane;
    @FXML
    private Pane graphPane;
    @FXML
    private ComboBox<String> startNodeComboBox;
    @FXML
    private ComboBox<String> endNodeComboBox;
    @FXML
    private Slider speedSlider;
    @FXML
    private Text currentStateText;
    @FXML
    private ListView<NodeDistance> priorityQueueListView;
    @FXML
    private ListView<String> distancesListView;
    @FXML
    private Label totalPathCostLabel;
    @FXML
    private Label statusLabel;
    @FXML private Button playButton;
    @FXML private Button pauseButton;
    @FXML private Button stepForwardButton;
    @FXML private Button stepBackwardButton;

    // --- Graph Builder Mode ---
    private boolean addNodeMode = false;
    private boolean addEdgeMode = false;
    private UINode selectedNodeForEdge = null; // To store the first node selected for an edge

    // --- JGraphT Graph Instance ---
    // We'll declare this in Phase 2
    private Graph<String, DefaultWeightedEdge> jgraphtGraph;
    private Map<String, UINode> uiNodes;
    private List<UIEdge> uiEdges;
    // private Map<String, UIEdge> uiEdges;

    private int nodeIdCounter = 0;

    // --- Dijkstra Algorithm Visualization State ---
    private List<AlgorithmStep> currentAlgorithmSteps; // Stores all steps generated by Dijkstra
    private int currentStepIndex = -1; // Current step being displayed (-1 for not started)
    private Timeline animationTimeline; // For automatic playback

    private String currentStartNodeId; // To store the start node ID for the current algorithm run
    private String currentEndNodeId;   // To store the end node ID for the current algorithm run

    // --- Graph Initialization ---
    private void initializeGraph() {
        jgraphtGraph = new org.jgrapht.graph.DefaultUndirectedWeightedGraph<>(DefaultWeightedEdge.class);
        uiNodes = new HashMap<>();
        uiEdges = new ArrayList<>();
        graphPane.getChildren().clear(); // Clear any existing nodes/edges
        nodeIdCounter = 0; // Reset node counter

        // Clear ComboBox items
        startNodeComboBox.getItems().clear();
        endNodeComboBox.getItems().add(""); // Add empty string for default selection
        startNodeComboBox.getItems().add(""); // Add empty string for default selection


        totalPathCostLabel.setText("N/A");
        currentStateText.setText("");
        priorityQueueListView.setItems(FXCollections.observableArrayList());
        distancesListView.setItems(FXCollections.observableArrayList());

        // Also reset visualization state if any algorithm was run
        currentAlgorithmSteps = null; // Clear steps
        currentStepIndex = -1;
        if (animationTimeline != null) {
            animationTimeline.stop();
        }

        // Reset modes
        addNodeMode = false;
        addEdgeMode = false;
        selectedNodeForEdge = null;
    }

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        // Initialize graph and UI components
        jgraphtGraph = new org.jgrapht.graph.DefaultUndirectedWeightedGraph<>(org.jgrapht.graph.DefaultWeightedEdge.class);
        uiNodes = new HashMap<>();
        uiEdges = new ArrayList<>(); // Using ArrayList for UIEdges

        // Ensure graphPane gets mouse events and requests focus
        graphPane.setOnMouseClicked(this::handleGraphPaneClick);
        graphPane.setFocusTraversable(true); // Allow pane to receive focus if needed

        // Set up the ComboBoxes (assuming they are FXML injected)
        startNodeComboBox.setItems(FXCollections.observableArrayList());
        endNodeComboBox.setItems(FXCollections.observableArrayList());

        // Initial status message
        statusLabel.setText("Click 'Add Node' to start building your graph, then 'Add Edge' to connect them.");

        // Initialize lists for algorithm display
        priorityQueueListView.setItems(FXCollections.observableArrayList());
        distancesListView.setItems(FXCollections.observableArrayList());

        // Listener for the speed slider to adjust animation speed
        speedSlider.valueProperty().addListener((obs, oldVal, newVal) -> {
            // Only adjust if there's an active animation timeline
            if (animationTimeline != null && animationTimeline.getStatus() == Timeline.Status.RUNNING) {
                animationTimeline.stop(); // Stop the current animation
                // Re-create the timeline with the new speed setting
                animationTimeline = new Timeline();
                animationTimeline.setCycleCount(Timeline.INDEFINITE);
                animationTimeline.getKeyFrames().add(
                        new KeyFrame(Duration.seconds(newVal.doubleValue()), e -> {
                            if (currentStepIndex < currentAlgorithmSteps.size() - 1) {
                                currentStepIndex++;
                                // *** CRITICAL CHANGE: Pass the current step to displayCurrentStep ***
                                displayCurrentStep(currentAlgorithmSteps.get(currentStepIndex));
                            } else {
                                // Reached the end of the algorithm steps during playback
                                animationTimeline.stop();
                                playButton.setText("Play"); // Reset play button text
                                stepForwardButton.setDisable(true); // Disable forward navigation
                                playButton.setDisable(true); // Disable play button
                                pauseButton.setDisable(true); // Disable pause button
                            }
                        })
                );
                animationTimeline.play(); // Start the animation again with the new speed
            }
        });
    }


    // --- FXML Event Handlers (stubbed for now) ---

    @FXML
    private void handleNewGraph() {
        System.out.println("New Graph clicked");
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION, "Are you sure you want to clear the current graph?", ButtonType.YES, ButtonType.NO);
        alert.setTitle("New Graph");
        Optional<ButtonType> result = alert.showAndWait();
        if (result.isPresent() && result.get() == ButtonType.YES) {
            initializeGraph();
            statusLabel.setText("New graph created. Click 'Add Node' to start.");
            addNodeMode = false;
            addEdgeMode = false;
            selectedNodeForEdge = null;
        }
    }

    @FXML
    private void handleLoadGraph() {
        System.out.println("Load Graph clicked");
        // Logic to load graph from a file
    }

    @FXML
    private void handleSaveGraph() {
        System.out.println("Save Graph clicked");
        // Logic to save graph to file
    }

    @FXML
    private void handleExit() {
        System.out.println("Exit clicked");
        System.exit(0);
    }

    @FXML
    private void handleRunDijkstra() {
        System.out.println("Run Dijkstra clicked");
        // Logic to start Dijkstra visualization
    }

    @FXML
    private void handleResetAlgorithm() {
        System.out.println("Reset Algorithm clicked");

        // Stop any ongoing animation
        if (animationTimeline != null) {
            animationTimeline.stop();
        }

        // Reset all UI elements related to algorithm visualization
        totalPathCostLabel.setText("N/A");
        currentStateText.setText("");
        priorityQueueListView.setItems(FXCollections.observableArrayList()); // Clear list
        distancesListView.setItems(FXCollections.observableArrayList());     // Clear list

        // Reset all node and edge styles to their default
        resetNodeStyles();  // This method should already exist from previous steps
        clearEdgeStyles();  // This method should already exist from previous steps

        // Reset algorithm state variables
        currentAlgorithmSteps = null; // Clear all stored steps
        currentStepIndex = -1; // Reset step index

        // Reset button states for algorithm controls
        // All should be disabled as no algorithm is running
        if (playButton != null) playButton.setDisable(true);
        if (pauseButton != null) pauseButton.setDisable(true);
        if (stepForwardButton != null) stepForwardButton.setDisable(true);
        if (stepBackwardButton != null) stepBackwardButton.setDisable(true);

        statusLabel.setText("Algorithm reset. Select nodes and click 'Run Algorithm' to start a new visualization.");
    }

    @FXML
    private void handleAbout() {
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("About Dijkstra's Shortest Path Visualizer");
        alert.setHeaderText("Version 1.0");
        alert.setContentText("Developed as a project to visualize Dijkstra's algorithm.\n" +
                "Uses JavaFX for UI and JGraphT for graph data structures.");
        alert.showAndWait();
    }

    // --- Node and Edge Creation Logic ---
    @FXML
    private void handleAddNodeMode() {
        addNodeMode = true;
        addEdgeMode = false; // Ensure only one mode is active
        statusLabel.setText("Add Node mode active. Click on the panel to add nodes.");
        System.out.println("Add Node mode active.");
    }

    @FXML
    private void handleAddEdgeMode() {
        addNodeMode = false;
        addEdgeMode = true; // Ensure only one mode is active
        selectedNodeForEdge = null; // Clear any previous selection
        statusLabel.setText("Add Edge mode active. Click on the first node, then the second.");
        System.out.println("Add Edge mode active.");
    }

    @FXML
    private void handleFindShortestPath() {
        System.out.println("Find Shortest Path clicked");
        // Logic to trigger the shortest path finding
    }

    @FXML
    private void handlePlay() {
        System.out.println("Play clicked");
        if (currentAlgorithmSteps == null || currentAlgorithmSteps.isEmpty()) {
            return; // No steps to play
        }

        // If we're at the very end, reset to the beginning to start playback from scratch
        if (currentStepIndex >= currentAlgorithmSteps.size() - 1) {
            currentStepIndex = 0;
            // *** CRITICAL CHANGE: Pass the current step to displayCurrentStep ***
            displayCurrentStep(currentAlgorithmSteps.get(currentStepIndex)); // Show the first step before starting play
        }

        // Initialize or restart the timeline
        if (animationTimeline == null) {
            animationTimeline = new Timeline();
            animationTimeline.setCycleCount(Timeline.INDEFINITE); // Play until explicitly stopped or end reached
            animationTimeline.getKeyFrames().add(
                    new KeyFrame(Duration.seconds(speedSlider.getValue()), e -> { // Use speedSlider for duration
                        if (currentStepIndex < currentAlgorithmSteps.size() - 1) {
                            currentStepIndex++;
                            // *** CRITICAL CHANGE: Pass the current step to displayCurrentStep ***
                            displayCurrentStep(currentAlgorithmSteps.get(currentStepIndex));
                        } else {
                            // Reached the end of the algorithm steps
                            animationTimeline.stop();
                            playButton.setText("Play"); // Reset button text
                            // Button disabling logic is primarily handled by displayCurrentStep()
                            // but ensuring here for robustness if animation stops
                            stepForwardButton.setDisable(true);
                            playButton.setDisable(true);
                            pauseButton.setDisable(true);
                        }
                    })
            );
        } else {
            // If timeline exists, ensure the duration updates if slider value changed
            animationTimeline.getKeyFrames().setAll(
                    new KeyFrame(Duration.seconds(speedSlider.getValue()), e -> {
                        if (currentStepIndex < currentAlgorithmSteps.size() - 1) {
                            currentStepIndex++;
                            // *** CRITICAL CHANGE: Pass the current step to displayCurrentStep ***
                            displayCurrentStep(currentAlgorithmSteps.get(currentStepIndex));
                        } else {
                            animationTimeline.stop();
                            playButton.setText("Play");
                            // Button disabling logic is primarily handled by displayCurrentStep()
                            stepForwardButton.setDisable(true);
                            playButton.setDisable(true);
                            pauseButton.setDisable(true);
                        }
                    })
            );
        }

        animationTimeline.play();
        playButton.setText("Pause"); // Change button text to "Pause" when playing
        pauseButton.setDisable(false); // Enable pause button
    }

    @FXML
    private void handlePause() {
        System.out.println("Pause clicked");
        if (animationTimeline != null) {
            animationTimeline.pause();
            playButton.setText("Play"); // Change button text back to "Play"
            pauseButton.setDisable(true); // Disable pause button once paused
        }
    }

    @FXML
    private void handleStepForward() {
        System.out.println("Step Forward clicked");
        if (currentAlgorithmSteps == null || currentAlgorithmSteps.isEmpty()) {
            return; // No steps to show
        }

        if (currentStepIndex < currentAlgorithmSteps.size() - 1) {
            currentStepIndex++;
            // *** CRITICAL CHANGE: Pass the current step to displayCurrentStep ***
            displayCurrentStep(currentAlgorithmSteps.get(currentStepIndex));
            // Stop any ongoing auto-play when manually stepping
            if (animationTimeline != null) {
                animationTimeline.stop();
                playButton.setText("Play"); // Reset button text if it changed
            }
        }
        // Button disabling logic for reaching the end is now primarily handled by displayCurrentStep()
        // and also implicitly by the timeline's onFinished/KeyFrame logic in handlePlay
    }

    @FXML
    private void handleStepBackward() {
        System.out.println("Step Backward clicked");
        if (currentAlgorithmSteps == null || currentAlgorithmSteps.isEmpty()) {
            return; // No steps to show
        }

        if (currentStepIndex > 0) {
            currentStepIndex--;
            // *** CRITICAL CHANGE: Pass the current step to displayCurrentStep ***
            displayCurrentStep(currentAlgorithmSteps.get(currentStepIndex));
            // Stop any ongoing auto-play when manually stepping
            if (animationTimeline != null) {
                animationTimeline.stop();
                playButton.setText("Play"); // Reset button text if it changed
            }
        }
        // Button disabling logic for reaching the beginning is now primarily handled by displayCurrentStep()
    }

    // --- MODIFIED: handleGraphPaneClick - now only for clicks NOT on nodes ---
    @FXML
    private void handleGraphPaneClick(MouseEvent event) {
        // This method will only be called if a node was NOT clicked,
        // because UINode consumes the event.
        if (addNodeMode) {
            addNode(event.getX(), event.getY());
        } else if (addEdgeMode) {
            // If we're in addEdgeMode and reach here, it means the click was on the pane, not a node.
            statusLabel.setText("No node clicked. Please click directly on a node.");
            if (selectedNodeForEdge != null) {
                selectedNodeForEdge.setDefaultStyle(); // Reset its style
                selectedNodeForEdge = null; // Clear the selection
                statusLabel.setText("Edge creation cancelled. Select first node for a new edge.");
            }
        }
        // No need for findClickedNode here anymore for node detection.
    }

    // This method will be linked to the graphPane's onMouseClicked event in FXML (or code)
    // @FXML
    // private void handleGraphPaneClick(MouseEvent event) { ... }

    // --- Helper to add a node ---
    private void addNode(double x, double y) {
        String nodeId = "Node" + nodeIdCounter++;
        UINode newNode = new UINode(nodeId, x, y);

        // Set the click handler for the UINode itself
        newNode.setOnClickHandler(this::handleNodeClickForEdge);

        // Add to map and pane
        uiNodes.put(nodeId, newNode);
        graphPane.getChildren().add(newNode);

        // --- IMPORTANT: ADD THIS LINE ---
        jgraphtGraph.addVertex(nodeId); // Add the vertex to the JGraphT graph
        System.out.println("Added vertex to JGraphT: " + nodeId); // Add this debug print

        startNodeComboBox.getItems().add(nodeId);
        endNodeComboBox.getItems().add(nodeId);
        System.out.println("Added node: " + nodeId);
    }

    // --- Helper to find which node was clicked ---
    private UINode findClickedNode(double mouseX, double mouseY) {
        for (UINode node : uiNodes.values()) {
            // Check if click is within the circle's bounds
            if (node.getCircle().getBoundsInParent().contains(mouseX, mouseY)) {
                return node;
            }
        }
        return null;
    }

    // --- Helper to show weight input dialog ---
    private void showWeightInputDialog(UINode source, UINode target) {
        TextInputDialog dialog = new TextInputDialog("1"); // Default weight
        dialog.setTitle("Edge Weight");
        dialog.setHeaderText("Enter weight for edge " + source.getNodeId() + " - " + target.getNodeId());
        dialog.setContentText("Weight:");

        Optional<String> result = dialog.showAndWait();
        if (result.isPresent()) {
            try {
                double weight = Double.parseDouble(result.get());
                if (weight <= 0) {
                    Alert alert = new Alert(Alert.AlertType.ERROR);
                    alert.setTitle("Invalid Weight");
                    alert.setHeaderText(null);
                    alert.setContentText("Weight must be a positive number.");
                    alert.showAndWait();
                    // If invalid, still reset node styles and keep selection process active
                    // Or you might choose to clear selection here too.
                    source.setDefaultStyle(); // Reset source style
                    target.setDefaultStyle(); // Reset target style
                    selectedNodeForEdge = null; // Clear selection
                    return; // Exit as weight is invalid
                }
                // Add the edge to JGraphT and UI
                addGraphEdge(source, target, weight);

                // After successful edge creation, clear the selection and reset styles
                selectedNodeForEdge = null; // Clear selected node
                source.setDefaultStyle(); // Reset source node style
                target.setDefaultStyle(); // Reset target node style

            } catch (NumberFormatException e) {
                Alert alert = new Alert(Alert.AlertType.ERROR);
                alert.setTitle("Invalid Input");
                alert.setHeaderText(null);
                alert.setContentText("Please enter a valid number for the weight.");
                alert.showAndWait();
                // If invalid input, reset node styles and clear selection
                source.setDefaultStyle();
                target.setDefaultStyle();
                selectedNodeForEdge = null;
            }
        } else {
            // User cancelled the dialog, so clear the selection and reset styles
            source.setDefaultStyle();
            target.setDefaultStyle();
            selectedNodeForEdge = null;
        }
    }

    private void addGraphEdge(UINode sourceUINode, UINode targetUINode, double weight) {
        String sourceId = sourceUINode.getNodeId();
        String targetId = targetUINode.getNodeId();

        try {
            // 1. Add edge to JGraphT graph
            DefaultWeightedEdge edge = jgraphtGraph.addEdge(sourceId, targetId);
            if (edge == null) {
                // This can happen if the edge already exists (though we check this in handleNodeClickForEdge)
                // or if source/target nodes don't exist in jgraphtGraph (shouldn't happen here)
                System.err.println("Failed to add JGraphT edge between " + sourceId + " and " + targetId);
                return;
            }
            jgraphtGraph.setEdgeWeight(edge, weight);

            // 2. Create UIEdge object
            UIEdge uiEdge = new UIEdge(sourceUINode, targetUINode, weight);
            uiEdge.setDefaultStyle(); // Apply default style

            // 3. Add UIEdge to the graphPane for display
            // Important: Add edges BEFORE nodes so nodes appear on top
            graphPane.getChildren().add(0, uiEdge); // Add at index 0 to put it behind nodes

            // 4. Add UIEdge to your tracking list/map
            uiEdges.add(uiEdge); // Assuming uiEdges is an ArrayList<UIEdge>

            // 5. Update Combo Boxes with target node if it wasn't already in the list (redundant if already added by addNode)
            // This part is mainly for ensuring combo boxes are populated with all nodes.
            // It's usually handled by the addNode method when a node is initially created.
            // If a node is added *only* via edge creation to the JGraphT model without a UI node yet,
            // you'd need to add it to uiNodes as well, but that's not the current flow.
            // So, this specific update for combo boxes is probably not strictly necessary here if addNode does its job.

            statusLabel.setText("Edge added: " + sourceId + " - " + targetId + " (Weight: " + weight + ")");

        } catch (IllegalArgumentException e) {
            // This might catch cases where nodes don't exist in JGraphT if you added error checking earlier
            System.err.println("Error adding edge to JGraphT: " + e.getMessage());
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Graph Error");
            alert.setHeaderText("Failed to add edge");
            alert.setContentText("An error occurred while adding the edge: " + e.getMessage());
            alert.showAndWait();
        }
    }

    // --- Helper to add an edge ---
    private void addEdge(UINode source, UINode target, double weight) {
        // Check if edge already exists to prevent duplicates (for undirected graph)
        if (jgraphtGraph.containsEdge(source.getNodeId(), target.getNodeId()) ||
                jgraphtGraph.containsEdge(target.getNodeId(), source.getNodeId())) {
            statusLabel.setText("Edge already exists between " + source.getNodeId() + " and " + target.getNodeId());
            return;
        }

        // Add to JGraphT graph
        DefaultWeightedEdge jgraphtEdge = jgraphtGraph.addEdge(source.getNodeId(), target.getNodeId());
        jgraphtGraph.setEdgeWeight(jgraphtEdge, weight);

        // Add to JavaFX pane
        UIEdge uiEdge = new UIEdge(source, target, weight);
        uiEdges.add(uiEdge);
        graphPane.getChildren().add(0, uiEdge); // Add edges below nodes
        statusLabel.setText("Edge added between " + source.getNodeId() + " and " + target.getNodeId() + " with weight " + weight + ".");
        System.out.println("Added edge: " + source.getNodeId() + " - " + target.getNodeId() + " with weight " + weight);
    }

    // --- NEW: Handler for clicks directly on a UINode for edge creation ---
    private void handleNodeClickForEdge(UINode clickedNode) {
        if (!addEdgeMode) {
            return;
        }

        System.out.println("Node clicked for edge: " + clickedNode.getNodeId());

        if (selectedNodeForEdge == null) {
            // This is the first node being selected for an edge
            selectedNodeForEdge = clickedNode;
            selectedNodeForEdge.highlightAsSelectedForEdge(); // Apply highlight style
            statusLabel.setText("First node selected: " + clickedNode.getNodeId() + ". Click second node or background to cancel.");
        } else if (selectedNodeForEdge.equals(clickedNode)) {
            // User clicked the same node again - deselect it
            selectedNodeForEdge.setDefaultStyle(); // Reset its style
            selectedNodeForEdge = null; // Clear selection
            statusLabel.setText("Node " + clickedNode.getNodeId() + " deselected. Select first node for an edge.");
        } else {
            // This is the second node being selected for an edge
            // Before proceeding, check if an edge already exists
            if (jgraphtGraph.containsEdge(selectedNodeForEdge.getNodeId(), clickedNode.getNodeId())) {
                Alert alert = new Alert(Alert.AlertType.WARNING);
                alert.setTitle("Duplicate Edge");
                alert.setHeaderText(null);
                alert.setContentText("An edge already exists between " + selectedNodeForEdge.getNodeId() + " and " + clickedNode.getNodeId() + ".");
                alert.showAndWait();

                // Clear the selection of both nodes and reset their styles
                selectedNodeForEdge.setDefaultStyle();
                clickedNode.setDefaultStyle();
                selectedNodeForEdge = null;
                statusLabel.setText("Edge already exists. Select first node for a new edge.");
                return;
            }

            // Proceed to ask for weight and create edge
            showWeightInputDialog(selectedNodeForEdge, clickedNode);

            // showWeightInputDialog handles resetting styles and clearing selectedNodeForEdge
            // So, no need to do it here again unless showWeightInputDialog is not called.
        }
    }

    // --- Algorithm Execution ---

    @FXML
    private void handleRunAlgorithm() {
        // Get the selected start node
        currentStartNodeId = startNodeComboBox.getSelectionModel().getSelectedItem();
        // Get the selected end node. This can be null/empty for "all paths" mode.
        currentEndNodeId = endNodeComboBox.getSelectionModel().getSelectedItem();

        // 1. Validate Start Node selection
        if (currentStartNodeId == null || currentStartNodeId.isEmpty()) {
            Alert alert = new Alert(Alert.AlertType.WARNING);
            alert.setTitle("Missing Input");
            alert.setHeaderText(null);
            alert.setContentText("Please select a start node to run Dijkstra's algorithm.");
            alert.showAndWait();
            return;
        }

        // 2. Validate if selected nodes actually exist in the graph
        if (!uiNodes.containsKey(currentStartNodeId)) {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Node Not Found");
            alert.setHeaderText(null);
            alert.setContentText("The selected start node '" + currentStartNodeId + "' does not exist in the graph.");
            alert.showAndWait();
            return;
        }
        // Only validate end node if it's explicitly selected (not null/empty)
        if (currentEndNodeId != null && !currentEndNodeId.isEmpty() && !uiNodes.containsKey(currentEndNodeId)) {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Node Not Found");
            alert.setHeaderText(null);
            alert.setContentText("The selected end node '" + currentEndNodeId + "' does not exist in the graph.");
            alert.showAndWait();
            return;
        }

        // 3. Handle case where start and end nodes are the same (only if end node is selected)
        if (currentEndNodeId != null && !currentEndNodeId.isEmpty() && currentStartNodeId.equals(currentEndNodeId)) {
            Alert alert = new Alert(Alert.AlertType.WARNING);
            alert.setTitle("Invalid Selection");
            alert.setHeaderText(null);
            alert.setContentText("Start and end nodes cannot be the same.");
            alert.showAndWait();
            return;
        }


        // Stop any currently running animation before starting a new one
        if (animationTimeline != null) {
            animationTimeline.stop();
        }

        // Reset the UI and algorithm state before running a new one
        resetAlgorithm(); // This method should handle clearing the graph, lists, etc.

        // Determine if it's "all paths" mode
        boolean isAllPathsMode = (currentEndNodeId == null || currentEndNodeId.isEmpty());
        String effectiveEndNodeId = isAllPathsMode ? null : currentEndNodeId;

        // Run Dijkstra's algorithm with the selected start and (optional) end node
        // The runDijkstraAlgorithm method will populate currentAlgorithmSteps
        runDijkstraAlgorithm(currentStartNodeId, effectiveEndNodeId);

        // Prepare for visualization if steps were generated
        if (!currentAlgorithmSteps.isEmpty()) {
            currentStepIndex = 0;
            // *** CRITICAL CHANGE: Pass the first AlgorithmStep to displayCurrentStep ***
            displayCurrentStep(currentAlgorithmSteps.get(currentStepIndex));

            // Set initial button states
            stepBackwardButton.setDisable(true); // Always disabled at step 0
            // Enable forward/play only if there's more than one step
            stepForwardButton.setDisable(currentAlgorithmSteps.size() <= 1);
            playButton.setDisable(currentAlgorithmSteps.size() <= 1);
            pauseButton.setDisable(true); // Pause is disabled initially
            statusLabel.setText("Algorithm started. Use controls to navigate.");
        } else {
            statusLabel.setText("No steps generated. Graph might be empty, disconnected, or invalid.");
            // Ensure buttons remain disabled if no steps are generated
            stepBackwardButton.setDisable(true);
            stepForwardButton.setDisable(true);
            playButton.setDisable(true);
            pauseButton.setDisable(true);
        }
    }

    private void resetAlgorithm() {
        if (animationTimeline != null) {
            animationTimeline.stop();
            animationTimeline = null;
        }
        currentAlgorithmSteps = new ArrayList<>();
        currentStepIndex = -1;
        totalPathCostLabel.setText("Total Path Cost: N/A");
        currentStateText.setText("");
        statusLabel.setText("Ready.");
        priorityQueueListView.setItems(FXCollections.emptyObservableList());
        distancesListView.setItems(FXCollections.emptyObservableList());
        resetNodeStyles(); // Resets all node styles
        clearEdgeStyles(); // Clears all edge highlights
        // Clear graph if you recreate it on run, or just reset styles
        // Clear selections in the combo boxes
        startNodeComboBox.getSelectionModel().clearSelection();
        endNodeComboBox.getSelectionModel().clearSelection();
        // You might also want to set a prompt text to guide the user
        startNodeComboBox.setPromptText("Select Start Node");
        endNodeComboBox.setPromptText("Select End Node (Optional)");

        if (selectedNodeForEdge != null) {
            selectedNodeForEdge.setDefaultStyle(); // Explicitly reset the style of the previously selected node
            selectedNodeForEdge = null; // Clear the reference to the selected node
        }
        addNodeMode=false;
        addEdgeMode=false;
        statusLabel.setText("Graph reset. Select an operation mode to begin (e.g., Add Node, Add Edge, Run Dijkstra).");
    }

    // New helper method to clear all-edge highlights
    /*private void clearEdgeStyles() {
        for (UIEdge edge : uiEdges) {
            edge.resetStyle();
        }
    }*/

    // New helper method to reset all node styles (e.g., after a previous run)
    /*private void resetNodeStyles() {
        for (UINode node : uiNodes.values()) {
            node.resetStyle();
            node.updateDistanceLabel(Double.POSITIVE_INFINITY); // Reset displayed distance
        }
    }*/

    // --- Core Dijkstra's Algorithm Implementation ---
    private void runDijkstraAlgorithm(String startNodeId, String endNodeId) {
        currentAlgorithmSteps.clear();
        animationTimeline = null; // Ensure no old timeline is running

        // Step 1: Initialization
        Map<String, Double> distances = new HashMap<>(); // Stores shortest distance from startNode to each node
        Map<String, String> predecessors = new HashMap<>(); // Stores predecessor in the shortest path
        PriorityQueue<NodeDistance> pq = new PriorityQueue<>(); // Priority queue for Dijkstra's
        Set<String> visitedNodes = new HashSet<>(); // Set of nodes whose shortest path is finalized

        // Initialize distances
        for (String nodeId : jgraphtGraph.vertexSet()) {
            distances.put(nodeId, Double.POSITIVE_INFINITY);
            predecessors.put(nodeId, null); // No predecessor initially
        }
        distances.put(startNodeId, 0.0);
        pq.add(new NodeDistance(startNodeId, 0.0));

        // Record initial state
        currentAlgorithmSteps.add(new AlgorithmStep(
                AlgorithmStep.StepType.INITIALIZED, // Changed from INITIALIZATION
                "Initialized distances and priority queue. Start node: " + startNodeId,
                startNodeId, // currentNodeId (the start node itself)
                distances, pq, visitedNodes, predecessors,
                endNodeId // Pass the endNodeId (can be null)
        ));
        System.out.println("Dijkstra: Initialized.");

        // Step 2: Main loop
        while (!pq.isEmpty()) {
            NodeDistance current = pq.poll(); // Extract node with smallest distance
            String u = current.getNodeId();
            double uDistance = current.getDistance();

            // If already visited, skip (due to multiple entries in PQ from relaxations)
            if (visitedNodes.contains(u)) {
                continue;
            }

            // Mark node as visited (the shortest path finalized)
            visitedNodes.add(u);

            // Record node extracted step
            currentAlgorithmSteps.add(new AlgorithmStep(
                    AlgorithmStep.StepType.NODE_EXTRACTED,
                    "Extracted node: " + u + " with distance " + String.format("%.1f", uDistance),
                    u, distances, pq, visitedNodes, predecessors,
                    endNodeId // Pass the endNodeId
            ));
            System.out.println("Dijkstra: Extracted " + u);

            // *** CRITICAL CHANGE: Only break if a specific endNodeId is provided AND reached ***
            if (endNodeId != null && u.equals(endNodeId)) {
                System.out.println("Dijkstra: Target node " + endNodeId + " reached. Terminating early for specific path.");
                break; // Target found, no need to process further if it's a specific path
            }

            // For each neighbor v of u
            for (DefaultWeightedEdge edge : jgraphtGraph.edgesOf(u)) {
                String v = Graphs.getOppositeVertex(jgraphtGraph, edge, u);
                double weight = jgraphtGraph.getEdgeWeight(edge);

                // If v is already visited, skip
                if (visitedNodes.contains(v)) {
                    continue;
                }

                // Relaxation
                // Check if distances.get(u) is not infinity before adding weight to prevent overflow if distance[u] is unreachable
                if (distances.get(u) != Double.POSITIVE_INFINITY && distances.get(u) + weight < distances.get(v)) {
                    distances.put(v, distances.get(u) + weight);
                    predecessors.put(v, u);
                    pq.add(new NodeDistance(v, distances.get(v)));

                    // Record edge relaxed step
                    currentAlgorithmSteps.add(new AlgorithmStep(
                            AlgorithmStep.StepType.EDGE_RELAXED,
                            "Relaxed edge " + u + "-" + v + ". New distance to " + v + ": " + String.format("%.1f", distances.get(v)),
                            u, u, v, // currentNodeId, relaxedSourceNodeId, relaxedTargetNodeId
                            distances, pq, visitedNodes, predecessors,
                            endNodeId // Pass the endNodeId
                    ));
                    System.out.println("Dijkstra: Relaxed " + u + "-" + v + " (new dist: " + String.format("%.1f", distances.get(v)) + ")");
                }
            }
        }

        // Step 3: Final Algorithm State / Path Construction
        // *** CRITICAL CHANGE: Differentiate between "all paths" mode and specific target ***
        if (endNodeId == null) {
            // Case 1: All paths mode (no specific end node was selected)
            currentAlgorithmSteps.add(new AlgorithmStep(
                    AlgorithmStep.StepType.ALGORITHM_FINISHED_ALL_PATHS,
                    "Dijkstra's Algorithm finished. Shortest distances to all reachable nodes computed from " + startNodeId + ".",
                    distances, pq, visitedNodes, predecessors
                    // No endNodeId or path needed for this constructor, isAllPathsMode is true by default
            ));
            System.out.println("Dijkstra: Algorithm finished for all reachable nodes from " + startNodeId + ".");
        } else {
            // Case 2: Specific end node mode
            double finalDistance = distances.getOrDefault(endNodeId, Double.POSITIVE_INFINITY);

            if (finalDistance == Double.POSITIVE_INFINITY) {
                // No path found to the specific end node
                currentAlgorithmSteps.add(new AlgorithmStep(
                        AlgorithmStep.StepType.NO_PATH_FOUND,
                        "No path found from " + startNodeId + " to " + endNodeId,
                        endNodeId, // currentNodeId (the unreachable end node)
                        distances, pq, visitedNodes, predecessors,
                        endNodeId // Pass the endNodeId
                ));
                System.out.println("Dijkstra: No path to " + endNodeId + " from " + startNodeId + ".");
            } else {
                // Path found to the specific end node
                List<String> path = reconstructPath(predecessors, startNodeId, endNodeId);
                currentAlgorithmSteps.add(new AlgorithmStep(
                        AlgorithmStep.StepType.PATH_FOUND, // Changed from ALGORITHM_COMPLETE
                        "Shortest path from " + startNodeId + " to " + endNodeId + " found. Cost: " + String.format("%.1f", finalDistance),
                        endNodeId, // currentNodeId (the end node)
                        distances, pq, visitedNodes, predecessors,
                        path, // Pass the reconstructed path
                        endNodeId // Pass the endNodeId
                ));
                System.out.println("Dijkstra: Path found to " + endNodeId + " from " + startNodeId + " with cost " + String.format("%.1f", finalDistance) + ".");
            }
        }

        // Removed direct totalPathCostLabel update here.
        // It will be handled in displayCurrentStep based on the final AlgorithmStep type.
    }

    private List<String> reconstructPath(Map<String, String> predecessors, String startNodeId, String endNodeId) {
        List<String> path = new ArrayList<>();
        String current = endNodeId;
        while (current != null && !current.equals(startNodeId)) {
            path.add(0, current); // Add to the beginning to reverse the path
            current = predecessors.get(current);
        }
        if (current != null && current.equals(startNodeId)) {
            path.add(0, startNodeId);
        } else {
            // This case should ideally not be hit if finalDistance was not infinity,
            // but for robustness, clear path if start is not reachable from end.
            path.clear();
        }
        return path;
    }

    // Helper to build the path description from predecessors map
    private String buildPathDescription(String startNodeId, String endNodeId, Map<String, String> predecessors, Map<String, Double> distances) {
        if (distances.get(endNodeId) == Double.POSITIVE_INFINITY) {
            return "No path.";
        }

        List<String> path = new ArrayList<>();
        String current = endNodeId;
        while (current != null && !current.equals(startNodeId)) {
            path.add(current);
            current = predecessors.get(current);
        }
        if (current != null && current.equals(startNodeId)) {
            path.add(startNodeId);
        } else {
            // This case should ideally not happen if distances.get(endNodeId) is not infinity,
            // but it's a safeguard for disconnected components.
            return "Path construction error (disconnected component?).";
        }
        Collections.reverse(path);
        return String.join(" -> ", path);
    }

    private void displayCurrentStep(AlgorithmStep step) {
        if (step == null) {
            return;
        }

        Platform.runLater(() -> {
            // --- UI Updates based on AlgorithmStep data ---
            currentStateText.setText(step.getDescription());

            // Update Priority Queue List View
            // Assuming AlgorithmStep.getPriorityQueueState() returns an ObservableList or compatible
            priorityQueueListView.setItems(step.getPriorityQueueState());

            // Update Distances List View
            ObservableList<String> distanceItems = FXCollections.observableArrayList();
            // Sort distances map by node ID for consistent display
            step.getDistances().entrySet().stream()
                    .sorted(Map.Entry.comparingByKey())
                    .forEach(entry -> {
                        String nodeId = entry.getKey();
                        Double dist = entry.getValue();
                        String distStr = (dist == Double.POSITIVE_INFINITY) ? "∞" : String.format("%.1f", dist);
                        distanceItems.add(nodeId + ": " + distStr);
                    });
            distancesListView.setItems(distanceItems);

            // --- Node and Edge Styling ---
            // Always reset styles at the beginning of a step to ensure a clean visualization
            resetNodeStyles();
            clearEdgeStyles();

            // Highlight visited nodes (nodes whose shortest path has been finalized)
            for (String visitedNodeId : step.getVisitedNodes()) {
                if (uiNodes.containsKey(visitedNodeId)) {
                    uiNodes.get(visitedNodeId).setVisitedStyle();
                }
            }

            // Highlight the current node being processed (e.g., extracted from PQ)
            if (step.getCurrentNodeId() != null && uiNodes.containsKey(step.getCurrentNodeId())) {
                uiNodes.get(step.getCurrentNodeId()).setCurrentStyle();
            }

            // Highlight the edge that was just relaxed
            // relaxedSourceNodeId and relaxedTargetNodeId are properties of AlgorithmStep
            if (step.getRelaxedSourceNodeId() != null && step.getRelaxedTargetNodeId() != null) {
                UIEdge uiEdge = findUIEdge(step.getRelaxedSourceNodeId(), step.getRelaxedTargetNodeId());
                if (uiEdge != null) {
                    uiEdge.setRelaxedStyle();
                }
            }

            // --- Control Button States (General for intermediate steps) ---
            // These control button states are general and apply to most steps.
            // Specific final states will override these.
            stepForwardButton.setDisable(currentStepIndex == currentAlgorithmSteps.size() - 1);
            stepBackwardButton.setDisable(currentStepIndex == 0);
            playButton.setDisable(currentStepIndex == currentAlgorithmSteps.size() - 1); // Disable play if at end
            pauseButton.setDisable(false); // Always allow pause if actively playing (will be disabled if play is disabled)


            // --- Handle specific StepTypes for final display and labels ---
            switch (step.getType()) {
                case INITIALIZED:
                case NODE_EXTRACTED:
                case EDGE_RELAXED:
                    // For intermediate steps, show "calculating" status and current progress
                    totalPathCostLabel.setText("Total Path Cost: Calculating...");
                    statusLabel.setText("Algorithm in progress: " + (currentStepIndex + 1) + "/" + currentAlgorithmSteps.size());
                    break;

                case PATH_FOUND:
                    // A specific path was found to the end node
                    List<String> path = step.getPath(); // Get the reconstructed path from AlgorithmStep
                    if (path != null && path.size() > 1) {
                        highlightPath(path); // Highlight the found path on the graph
                        double finalCost = step.getDistances().getOrDefault(step.getEndNodeId(), Double.POSITIVE_INFINITY);
                        totalPathCostLabel.setText(String.format("Total Path Cost: %.1f", finalCost));
                    } else {
                        // This case indicates an issue if PATH_FOUND type is used, but no valid path is available
                        totalPathCostLabel.setText("Total Path Cost: N/A (Path reconstruction error)");
                    }
                    statusLabel.setText(step.getDescription()); // Set status to the step's final description
                    // Highlight the final end node of the path
                    if (step.getEndNodeId() != null && uiNodes.containsKey(step.getEndNodeId())) {
                        uiNodes.get(step.getEndNodeId()).setPathEndStyle();
                    }

                    // Disable navigation and auto-play as the algorithm is complete for this specific path
                    stepForwardButton.setDisable(true);
                    playButton.setDisable(true);
                    pauseButton.setDisable(true);
                    break;

                case NO_PATH_FOUND:
                    // No path found to a specific target node
                    totalPathCostLabel.setText("Total Path Cost: Unreachable");
                    statusLabel.setText(step.getDescription()); // Set status to "No path found"
                    // Style the target node as unreachable
                    if (step.getEndNodeId() != null && uiNodes.containsKey(step.getEndNodeId())) {
                        uiNodes.get(step.getEndNodeId()).setUnreachableStyle();
                    }
                    // Disable navigation and auto-play
                    stepForwardButton.setDisable(true);
                    playButton.setDisable(true);
                    pauseButton.setDisable(true);
                    break;

                case ALGORITHM_FINISHED_ALL_PATHS:
                    // Algorithm completed, showing shortest distances to all reachable nodes
                    totalPathCostLabel.setText("Total Path Cost: N/A (All Distances Computed)");
                    statusLabel.setText(step.getDescription()); // Set status to "Algorithm finished for all paths"

                    // Style all nodes that were reached (have a finite distance)
                    for (String nodeId : step.getDistances().keySet()) {
                        if (step.getDistances().get(nodeId) != Double.POSITIVE_INFINITY) {
                            if (uiNodes.containsKey(nodeId)) {
                                // Use a style to indicate the node's distance is finalized
                                uiNodes.get(nodeId).setFinalizedStyle();
                            }
                        }
                    }
                    // In "all paths" mode, typically no single path is highlighted at the end, so clear edges
                    clearEdgeStyles();

                    // Disable navigation and auto-play as the algorithm is fully complete
                    stepForwardButton.setDisable(true);
                    playButton.setDisable(true);
                    pauseButton.setDisable(true);
                    break;

                default:
                    // Fallback for any unhandled step types (shouldn't happen if all are covered)
                    totalPathCostLabel.setText("Total Path Cost: N/A");
                    statusLabel.setText("Ready.");
                    break;
            }
        });
    }


    // Helper to find a UIEdge given source and target node IDs
    // Handles both directions for undirected graph display
    // Resets all UINode styles to their default
    private void resetNodeStyles() {
        for (UINode node : uiNodes.values()) {
            node.setDefaultStyle();
        }
    }

    // Resets all UIEdge styles to their default
    private void clearEdgeStyles() {
        for (UIEdge edge : uiEdges) { // Assuming uiEdges is an ArrayList<UIEdge>
            edge.setDefaultStyle();
        }
    }

    // Highlights the edges along a given path
    private void highlightPath(List<String> path) {
        if (path == null || path.size() < 2) return;
        for (int i = 0; i < path.size() - 1; i++) {
            String source = path.get(i);
            String target = path.get(i + 1);
            UIEdge uiEdge = findUIEdge(source, target);
            if (uiEdge != null) {
                uiEdge.setPathStyle(); // Apply path-specific style
            }
        }
    }

    // Finds a UIEdge given its source and target node IDs (handles undirected graphs)
    private UIEdge findUIEdge(String node1Id, String node2Id) {
        // Assuming uiEdges is an ArrayList<UIEdge>
        for (UIEdge edge : uiEdges) {
            // *** CRITICAL FIX: Access node IDs from the UINode objects ***
            String edgeSourceId = edge.getSourceNode().getNodeId();
            String edgeTargetId = edge.getTargetNode().getNodeId();

            if ((edgeSourceId.equals(node1Id) && edgeTargetId.equals(node2Id)) ||
                    (edgeSourceId.equals(node2Id) && edgeTargetId.equals(node1Id))) {
                return edge;
            }
        }
        return null;
    }


    // Placeholder for final path highlighting (will be implemented in Phase 4)
    private void highlightFinalPath(Map<String, String> predecessors, String startNodeId, String endNodeId) {
        // This method will be expanded in Phase 4
        // For now, just reset all edge styles then highlight the final path
        clearEdgeStyles(); // Ensure all edges are reset
        if (predecessors != null && predecessors.containsKey(endNodeId) && predecessors.get(endNodeId) != null) {
            String current = endNodeId;
            while (current != null && !current.equals(startNodeId)) {
                String predecessor = predecessors.get(current);
                if (predecessor != null) {
                    UIEdge edgeToHighlight = findUIEdge(predecessor, current);
                    if (edgeToHighlight != null) {
                        edgeToHighlight.highlightAsPath(); // New method in UIEdge
                    }
                }
                current = predecessor;
            }
        }
    }
}
